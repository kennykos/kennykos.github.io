Evaluate a spherical harmonics expansion on this grid.
That is, perform the spherical harmonics synthesis (inverse transform)
$$
f(\theta, \phi) = \sum_{l=0}^p \sum_{m=-l}^l f_l^m Y_l^m(\theta, \phi),
$$
where $f_n^m$ are the input coefficients.

For a fast transform, we rearrange the computation as
$$
f(\theta, \phi) = \sum_{m=-p}^p F_m(\theta) e^{im\phi},
$$
where $F_m = \sum_{l=|m|}^p f_l^m P_l^m(cos(\theta))$.
In addition, for real data, we have
$f_l^{-m} = \overline{f_l^m}$

Thus, our algorithm becomes
1. Compute F_m: shape (nph, nth)
2. Compute IFFT(F_m): shape ()

# Y_all slow
```
theta = self.theta.reshape(1,-1)   # shape: (1,nth)
phi = self.phi.reshape(-1,1)       # shape: (nph,1)
flm = self.coeff_vec_to_mat(coeff)                          # index (l,m)                                     
Ylm = sp.special.sph_harm_y_all(p,p,theta,phi)      # index (l,m,th,ph)                                       
Flm = (Ylm * flm[..., np.newaxis, np.newaxis])              # index (l,m,th)
f = np.zeros((self.nph, self.nth), dtype=np.complex128)    # index (ph, th)
print(Flm.shape, f.shape)
for l in range(p+1):
    for m in range(-l, l+1):
        f += Flm[l,m]
f = np.real(f).flatten(order='f')
return f
```

# P_all slow
```
flm = self.coeff_vec_to_mat(coeff)                          # index (l,m)
Plm = sp.special.sph_legendre_p_all(p,p,self.theta)[0]      # index (l,m,th)
Flm = (Plm * flm[..., np.newaxis])                          # index (l,m,th)
Fm = np.zeros((self.nph, self.nth), dtype=np.complex128)    # index (ph, th)
for m in range(-p, p + 1):
    l = abs(m)
    Fm[m, :] = np.sum(Flm[l:, m], axis=0)
f = np.fft.ifft(Fm, axis=0, norm="forward")                 # ifft over ph (unnormalized)
f = np.real(f).flatten(order='f')
return f
```

# Y_all fast
```
out = self.get_spharm_matrix(diff_n=diff_n, order=p)                                                          
val = out.T @ coeff
if real:
    val = np.real(val)
return val.T
```

# P_all fast

