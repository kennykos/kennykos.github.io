---
layout: post
title:  3D Morton Z-ordering for Cache-aware Near-field Interactions on a GPU. 
date:   2015-03-15 16:40:16
description: march & april, looking forward to summer
tags: 
categories: draft
giscus_comments: true
---

![Grid Traversal](../../../../assets/zorder/grid_traversals_2d.png){: style="max-width: 100%; height: auto;" }

# Background on $$N$$-body Simulations
Classical $$N$$-body simulations compute the *potential* $$\boldsymbol{u}(\boldsymbol{x}_i)$$ at a *target* particle $$\boldsymbol{x}_i \in \mathbb{R}^d$$ as the convolution with densities $$\boldsymbol{q}(\boldsymbol{y}_i)$$ of *source* particles $$\boldsymbol{y}_j\in \mathbb{R}^d$$. Formally, Given $$M$$ sources and $$N$$ targets, we express the $$N$$-body problem as

\begin{equation}
    \boldsymbol{u}(\boldsymbol{x}_i) = \sum_i^N K(\boldsymbol{x}_i, \boldsymbol{y}_j) \boldsymbol{q}(\boldsymbol{y}_j), \quad j = 1, \dots, M,
\end{equation}
where $$K(\boldsymbol{x}_i, \boldsymbol{y}_j)$$ is some convolution kernel. When $$M=N$$, solving an $$N$$-body problem has an asymptotic complexity of $$\mathcal{O}(N^2)$$, which is prohibitively expensive for modestly large systems (say $$N=1e6$$).

The canonical $$N$$-body problem considers the *electrostatic* potential derived by setting $$K(\boldsymbol{x}_i, \boldsymbol{y}_j) = G(\|\boldsymbol{x}_i - \boldsymbol{y}_j\|)$$, where $$G(\boldsymbol{r}) = \frac1{\|\boldsymbol{r}\|}$$ is the free-space Green's function for the Laplace equation $$\Delta u = 0$$. The electrostatic problem is indicative of many $$N$$-body problems as it's convolution kernel $$G(\boldsymbol{r})$$ is singular when $$\|\boldsymbol{r}\|$$ is small and smooth (hence easy to approximate) when $$\|\boldsymbol{r}\|$$ is large. This observation leads to an operator splitting 
$$
\begin{equation}
    \boldsymbol{u}(\boldsymbol{x}_i) = \boldsymbol{u}^{}(\boldsymbol{x}_i) + \boldsymbol{u}^{\mathcal{F}}(\boldsymbol{x}_i)
\end{equation}
$$
common to many fast methods (Ewald [1], Barnes–Hut [2], Fast-Multipole Method [3], etc.) ,where the near-field potential $$\boldsymbol{u}^{\mathcal{N}}$$ is given by some compactly supported near-field Green's function $$G^{\mathcal{N}}$$ and the far-field potential $$\boldsymbol{u}^{\mathcal{N}}$$ is given by some smooth far-field Greens function $$G^{\mathcal{F}}$$. For example, the Fast-Multipole Method sets 
$$
\begin{equation}
G^{\mathcal{N}}(\boldsymbol{r})=
\begin{cases}
G(\boldsymbol{r}) & \text{if } \|\boldsymbol{r}\| < r_c \\
0 & \text{otherwise}
\end{cases} \quad\text{ and } \quad
G^{\mathcal{F}}(\boldsymbol{r})=
\begin{cases}
G(\boldsymbol{r}) & \text{if } \|\boldsymbol{r}\| >= r_c \\
0 & \text{otherwise}
\end{cases},
\end{equation}
$$
where $$r_c$$ is some fixed cutoff radius. The general idea for fast methods is that a fixed $$r_c$$ leads to $$\mathcal{O}(n)$$ cost for the near-field potential $$\boldsymbol{u}^{\mathcal{N}}(\boldsymbol{x}_i) = \sum_i^N G^{\mathcal{N}}(\|\boldsymbol{x}_i-\boldsymbol{y}_j\|)\boldsymbol{q}(\boldsymbol{y}_j)$$ and the far-field potential $$\boldsymbol{u}^{\mathcal{F}}(\boldsymbol{x}_i) = \sum_i^N G^{\mathcal{F}}(\|\boldsymbol{x}_i-\boldsymbol{y}_j\|)\boldsymbol{q}(\boldsymbol{y}_j)$$ remains smooth and can be approximated in $$\mathcal{O}(n)$$ or $$\mathcal{O}(n\log n)$$ time.

![Split](../../../../assets/zorder/fmm_green_split.png){: style="max-width: 100%; height: auto;" }

# Computing the Near-field
For particles in $$\mathbb{R}^d$$, the near-field potential $$\boldsymbol{u}^{\mathcal{N}}(\boldsymbol{y}_j)$$ can be efficiently computed by partitioning the computational box $$\mathcal{B} = (L_x, L_y, L_z, \dots)$$ into cells $$\mathcal{C}_{\ell,m,n, \dots}$$, where $$L_x, L_y, L_z, \dots$$ are the side lengths of $$\mathcal{B}$$ in and $$\ell = 0, \dots, \lceil L_x/r_c \rceil$$, $$m = 0, \dots, \lceil L_y/r_c \rceil$$, $$n = 0, \dots, \lceil L_z/r_c \rceil$$ and so on. We will take $$d=3$$ and $$\mathcal{B} = (1,1,1)$$ for the remainder of this post. 

The cell list partition computationally prescribes the notion of locality into our near-field
in the sense that given a cell $$\mathcal{C}_{\ell,m,n}$$, for any target $$\boldsymbol{x}_i \in \mathcal{C}_{\ell,m,n}$$, we have that $$\sum_i^N G^{\mathcal{N}}(\|\boldsymbol{x}_i-\boldsymbol{y}_j\|)\boldsymbol{q}(\boldsymbol{y}_j)$$ is nonzero *only* for sources $$\boldsymbol{y}_j$$ in neighboring cells $$\mathcal{C}_{\ell + \delta_\ell,m +\delta_m,n +\delta_n}$$, where each of $$\delta_\ell, \delta_m,\delta_n$$ takes values $$-1,0, \text{ and } 1$$. Thus, given some map $$\mathrm{i2o}$$ (index-to-order) that takes $$(\ell+\delta_\ell, m+\delta_m,n+\delta_n) \mapsto k$$ and $$(\ell,m,n) \mapsto t$$ with inverse $$\mathrm{o2i}$$ (order-to-index), we can locally express the near-field problem as
$$
\begin{equation}
    \boldsymbol{u}^{\mathcal{N}}(\boldsymbol{x}_i) = \sum_{k=1}^{27} \sum_{\boldsymbol{y}_i \in \mathcal{C}_{\mathrm{o2i}(k)}} G^{\mathcal{N}}(\|\boldsymbol{x}_i-\boldsymbol{y}_j\|)\boldsymbol{q}(\boldsymbol{x_i}), \quad \forall ~ \boldsymbol{x}_i \in \mathcal{C}_{\mathrm{o2i}(t)}, \quad t = 0,\dots, \left( \frac{1}{\lceil r_c \rceil} \right)^3.
\end{equation}
$$

# Background on PyKokkos
...

# A Simple Parallel Near-Field code in PyKokkos
Let our computational box be defined as $$\mathcal{B} = [1,1,1]$$
and the average number of targets per cell be $$s = 64$$, and consider $$n=1e6$$ 
uniformly distributed particles. Thus, we
partition our box into $$25$$ cells ().

## Reshuffling into Cells

(TODO: insert figure here)

<!-- doing "```py" here should work, but everything is ugly and the font is wrong -->
```
import cupy as cp
import pykokkos as pk

@pk.function
def getNeighbor(cell: int, k: int) -> int:
    return cell

@pk.function
def t2c(team: int) -> int:
    return team

@pk.workunit
def near(team_member, x, y, q, u, s):
    t: int = team_member.league_rank()
    c: int = t2c(team) # team-to-cell index map
    def target_loop(i: int): #parfor
        x0: pk.doulbe = x[i][0]
        x1: pk.double = x[i][1]
        x2: pk.double = x[i][2]
        _u: pk.double = 0.0
        for k in range(27):
            off: int =  nc*getNeighbor(cell, k)
            for j in range(off, off+s):
                r0: pk.double = x0 - y[j][0]
                r1: pk.double = x1 - y[j][1]
                r2: pk.double = x2 - y[j][2]
                rsqr: pk.double = r0*r0*r1*r1*r2*r2
                rinv: pk.double = pk.rsqrt(rsqr) # fast 1/(sqrt(r))
                rinv = rinv + (rinv - rinv)
                rinv = pk.fmax(rinv, 0.0) # see [?] Lashuk et al.
                _u += rinv
        u[i] = _u


    pk.parallel_for(pk.TeamThreadRange(team_member, s), target_loop)

def main():
    # Problem setup
    n = 1000000
    box = [1,1,1]
    s = 64
    nc = n//s
    x = cp.random.uniform(size=(n,3)) # targets
    y = cp.random.uniform(size=(n,3)) # sources
    q = cp.random.uniform(size=n)     # charges
    u = cp.random.empty(size=n)       # potentials
    # Cuda kernel call
    pk.set_default_space(pk.Cuda)
    policy = pk.TeamPolicy(n_c, pk.AUTO)
    pk.parallel_for("near", policy, near, x=x, y=y, q=q, s=s)

main()
```

# References
[1] Ewald, P. P. (1921). Die Berechnung optischer und elektrostatischer Gitterpotentiale. Annalen Der Physik, 369(3), 253–287. https://doi.org/10.1002/andp.19213690304
[2] Barnes, J., & Hut, P. (1986). A hierarchical O(N log N) force-calculation algorithm. Nature, 324(6096), 446–449. https://doi.org/10.1038/324446a0
[3] Greengard, L., & Rokhlin, V. (1987). A fast algorithm for particle simulations. Journal of Computational Physics, 73(2), 325–348. https://doi.org/10.1016/0021-9991(87)90140-9